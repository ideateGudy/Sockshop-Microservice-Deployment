name: Deploying micro-service on AKS

on:
    push:
        branches: [ main ]
        paths:
            - 'infrastructure/**'  # Listens for changes in the 'terraform' folder
            - 'k8s/*.yaml'  # Listens for changes in the 'kubernetes' folder
            - 'kubernetes/monitoring/**'  # Listens for changes in the 'kubernetes/sock-shop-monitoring' folder
    workflow_dispatch:

#permissions:
 # id-token: write
 # contents: read
    

jobs:
    Test:
        # validates the format and correcttness of the Kubernetes manifests
        runs-on: ubuntu-latest
        steps:
        -   name: Checkout
            uses: actions/checkout@v3
        -   name: Install Kubeval
            run: |
                curl -sSL https://github.com/instrumenta/kubeval/releases/latest/download/kubeval-linux-amd64.tar.gz | tar -xz
                sudo mv kubeval /usr/local/bin/kubeval

        -   name: Validate Kubernetes manifests
            run: kubeval --ignore-missing-schemas k8s/*.yaml

    
    Infrastructure:
        # deploys or updates the infrastructure using Terraform, ignores if there was no change to infrastructure configuration
        runs-on: ubuntu-latest
        env:
             ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
             ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
             ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
             ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        steps:
        -   name: Checkout code
            uses: actions/checkout@v3
      
        -   name: Set up Terraform
            uses: hashicorp/setup-terraform@v2
            with:
              terraform_version: '1.9.3' 

    #    -   name: 'Az CLI login'
    #        uses: azure/login@v2
     #       with:
      #        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        #      tenant-id: ${{ secrets.AZURE_TENANT_ID }}
      #        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

        - name: Login to Azure using Service Principal
          uses: azure/login@v2
          with:
            client-id: ${{ secrets.AZURE_CLIENT_ID }}
            tenant-id: ${{ secrets.AZURE_TENANT_ID }}
            client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}
            subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

        
        -   name: Initialize Terraform
            working-directory: ./infrastructure
            run: terraform init

        -   name: Register Provider 
            working-directory: ./infrastructure
            run: az provider register --namespace Microsoft.TimeSeriesInsights
      
      
        -   name: Terraform Plan
            id: tf_plan
            working-directory: ./infrastructure 
            run: |
              terraform plan -detailed-exitcode -out=plan.tfplan
              echo "exit_code=$?" >> $GITHUB_ENV

        -   name: Check Plan Status
            id: check_plan_status
            run: |
              if [ "$exit_code" -eq 0 ]; then
                echo "No changes detected. Skipping apply."
                exit 0
              elif [ "$exit_code" -eq 2 ]; then
                echo "Changes detected. Proceeding with apply."
              else
                echo "Error during plan. Exiting."
                exit 1
              fi
            env:
              exit_code: ${{ env.exit_code }}

        -   name: Terraform Apply
            if: steps.check_plan_status.outcome == 'success' && env.exit_code == '2'
            working-directory: ./terraform
            run: terraform apply --auto-approve plan.tfplan
         

    Deploy:
        # deploys the application to Kubernetes cluster, this could include changes to parts of the configuration files.
        # changes like number of pods, memory, cpu, ingress, monitoring and alert configurations etc. 
        runs-on: ubuntu-latest
        needs: [Test, Infrastructure]
        steps:
        -   name: Checkout
            uses: actions/checkout@v3

        -   name: Setup Kubectl
            uses: azure/aks-set-context@v1
            with:
                creds: ${{ secrets.AZURE_CREDENTIALS }}
                cluster-name: ${{ secrets.AKS_CLUSTER_NAME }}
                resource-group: ${{ secrets.AKS_RESOURCE_GROUP }}

        -   name: Install Helm
            run: |
                curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
                chmod 700 get_helm.sh
                ./get_helm.sh

        -   name: Check if cert-manager is installed
            id: check-cert-manager
            run: |
                if kubectl get pods --namespace cert-manager | grep cert-manager; then
                 echo "cert-manager is already installed"
                 echo "install=false" >> $GITHUB_ENV
                else
                 echo "cert-manager is not installed"
                 echo "install=true" >> $GITHUB_ENV
                fi

        -   name: Install CertManager
            if: env.install == 'true'
            run: |
                kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.15.2/cert-manager.crds.yaml
                helm repo add jetstack https://charts.jetstack.io
                helm repo update
                helm install cert-manager --namespace cert-manager --version v1.15.2 jetstack/cert-manager
        
     #   -   name: Deploy to Kubernetes
           # run: |
          #      cd k8s
             #   ./
